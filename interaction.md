# Основная концепция взаимодействия

Концепция _'Ты мне на пир, я тебе на пир'_. 

Основная суть в том что клиент отправляет сообщение именно на пир своего собеседника, то есть на пир который _'обслуживает вашего собеседника'_

Под _'обслуживает'_ имеется в виду _прослушивание_ пира на наличие новых сообщений.

__Ситуация__, _клиент 1_ отправил сообщение _клиенту 2_:
```
+------------+        +-----------------+        +------------+
|  Клиент 1  | -----> |      Пир 2      | <--?-- |  Клиент 2  |
| (на Пире 1)|        | (Обслуживает    | -----> | (на Пире 2)|
+------------+        | Клиента 2)      |        +------------+ 
                      +-----------------+
```

_клиент 2_ ответил сообщением _клиенту 1_:
```
+------------+        +-----------------+        +------------+
|  Клиент 2  | -----> |      Пир 1      | <--?-- |  Клиент 1  |
| (на Пире 2)|        | (Обслуживает    | -----> | (на Пире 1)|
+------------+        | Клиента 1)      |        +------------+
                      +-----------------+
```

`<--?--` - означает вопрос к пиру _'а есть ли у меня сообщения?'_

При __keepalive соединении__ - сервер сам уведомит клиента о наличии новых сообщений, но если __клиент был не в сети__ - он может обратится к серверу и спросить о наличии новых сообщений, сервер предоставит ему их если сам помнит. _(Так как в целях безопасности всё сохраняется ТОЛЬКО в RAM - после рестарта сервер ествественно не будет ничего помнить)_

Из этой концепции так же исходит и то, что если ваш пир выходит из строя то вы не сможете получать сообщения, но сможете их отправлять __при условии что пир собеседника доступен__. И обратная ситуация, вы не  сможете отправить сообщение собеседнику если его пир вышел из строя, но сможете получать сообщения от него, **опять же при условии что вас обслуживают разные пиры**.

# Взаимодействие между узлами сети

_Весь Payload это payload относительно Root_

_Взаимодействие между клиентом и сервером не зашифрованно из-за того что его трудно таковым сделать, клиент и сервер конечно так же могут обменятся сертификатами, но так как сеть децентрализованная, определить подделку сертификата от сервера гораздо труднее чем от второго клиента, так как клиенты могут сравнить уникальные 6ти значные коды друг у друга в отличии от сервера где автоматизированно этого не сделать. Это так же дает некое преимущество - на самом сервере ничего конфиденциального хранится не может._

## _Регистрация_ клиента на сервере
_Регистрация_ подразумевает простую передачу сертификата на сервер для дальнейшего сопоставления его отпечатка с вашим IP:PORT, соотвественно чтобы сервер знал куда передать полученные для вас сообщения, ну или как минимум уведомления о них. А так же для 

Такая _регистрация_ выполняется каждый раз когда открывается соединение (То есть при перезапуске приложения, и при смене сети)

- __Клиент__ отправляет серверу (пиру) __пакет о регистрации в его _юрисдикции___:

  __Root payload type:__ 2

  __Payload:__
  ```
  [ Cert length - 2 byte (uint16) ] [ Cert ]
  ```
  
  _Собственно 'знакомимся с пиром' отправляя ему сертификат, чтобы тот знал что мы под таким то IP:PORT адресом._

- __Сервер__ сохраняет сертификат клиента и создает sha256 fingerprint на основе его сертификата для сопоставление в локальной БД. И отправляет ответ OK.
  
  _литерали: `map[sha256 client fingerprint]ClientData`_

  __Пакет об успешной операции__:
  
  __Root payload type:__ 1

  __Payload:__ _Не предусмотрен_

  _Если ответ от сервера не поступил в течении определенного времени, клиент делает регистрацию повторно, после пары неудачных попыток выносит вердикт 'Пир недоступен'_

- __Клиент__ после удачной регистрации отправляет __пакет keepalive__ каждые пару минут.

  _Таймаут можно выбрать по сути любой, сильно зависит от типа сети и оператора. Для IPv6 его в целом по идее можно не слать._

  _Это действие **может быть опциональным** еще в том случае, когда клиент подключается к **стороннему пиру**, то есть **к тому который его не обслуживает**, например к пиру собеседника для того чтобы просто передать сообщение, ведь ему не нужно прослушивать от него 'уведомления' так как 'уведомления' о новых сообщениях как и сами сообщения он получает на своем пиру._
  
  _Сам пакет предназначен для поддержания 'Дыры в NAT', поэтому в никаком payload не нуждается._
