# Взаимодействие между узлами сети

_Весь Payload это payload относительно Root_

_Взаимодействие между клиентом и сервером не зашифрованно из-за того что его трудно таковым сделать, клиент и сервер конечно так же могут обменятся сертификатами, но так как сеть децентрализованная, определить подделку сертификата от сервера гораздо труднее чем от второго клиента, так как клиенты могут сравнить уникальные 6ти значные коды друг у друга в отличии от сервера где автоматизированно этого не сделать. Это так же дает некое преимущество - на самом сервере ничего конфиденциального хранится не может._

## _Регистрация_ клиента на сервере
_Регистрация_ подразумевает простую передачу сертификата на сервер для дальнейшего сопоставления его отпечатка с вашим IP:PORT, соотвественно чтобы сервер знал куда передать полученные для вас сообщения, ну или как минимум уведомления о них.

Такая _регистрация_ выполняется каждый раз когда открывается соединение (То есть при перезапуске приложения, и при смене сети)

- __Клиент__ отправляет серверу (пиру) __пакет о регистрации в его _юрисдикции___:

  __Root payload type:__ 2

  __Payload:__
  ```
  [ Cert length - 2 byte (uint16) ] [ Cert ]
  ```
  
  _Собственно 'знакомимся с пиром' отправляя ему сертификат, чтобы тот знал что мы под таким то IP:PORT адресом._

- __Сервер__ сохраняет сертификат клиента и создает sha256 fingerprint на основе его сертификата для сопоставление в локальной БД. И отправляет ответ OK.
  
  _литерали: `map[sha256 client fingerprint]ClientData`_

  __Пакет об успешной операции__:
  
  __Root payload type:__ 1

  __Payload:__ _Не предусмотрен_

  _Если ответ от сервера не поступил в течении определенного времени, клиент делает регистрацию повторно, после пары неудачных попыток выносит вердикт 'Пир недоступен'_

- __Клиент__ после удачной регистрации отправляет __пакет keepalive__ каждые пару минут.

  _Таймаут можно выбрать по сути любой, сильно зависит от типа сети и оператора. Для IPv6 его в целом по идее можно не слать._

  _Сам пакет предназначен для поддержания 'Дыры в NAT', поэтому в никаком payload не нуждается._

## ~~Получение Events от сервера~~ 

__Сервер__ отправляет клиенту __пакет о новом событии__:

- Payload type: __3__ в случае если Event от самого сервера, __4__ в случае если Event от другого клиента.
  
- Payload __в первом случае__: _Потом придумаю._

- Payload __во втором случае__:
  ```
  [ Fingerprint of remote client - 32 bytes ] [ Event Payload (Потом придумаю) ]
